<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ—¥æœ¬æŠ½é¸å™¨</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        .title {
            color: white;
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .game-container {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            position: relative;
        }

        /* æ—¥æœ¬é¸çå™¨æ”¯æ¶æ¨£å¼ - ä»¿ç…§ä¸Šå‚³åœ–ç‰‡ */
        .lottery-machine {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .machine-stand {
            width: 600px;
            height: 120px;
            background: 
                linear-gradient(
                    180deg,
                    #CD853F 0%,
                    #D2691E 20%,
                    #8B4513 50%,
                    #654321 80%,
                    #4A4A4A 100%
                );
            border-radius: 20px 20px 40px 40px;
            position: relative;
            box-shadow: 
                0 8px 25px rgba(0,0,0,0.5),
                inset 0 3px 12px rgba(255,255,255,0.15),
                inset 0 -8px 20px rgba(0,0,0,0.4);
            border: 3px solid #4A4A4A;
            margin-top: -30px;
            z-index: -1;
        }

        .wood-grain {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                repeating-linear-gradient(
                    0deg,
                    transparent 0px,
                    rgba(139,69,19,0.2) 2px,
                    transparent 4px,
                    rgba(160,82,45,0.15) 6px,
                    transparent 8px
                ),
                repeating-linear-gradient(
                    90deg,
                    rgba(139,69,19,0.1) 0px,
                    transparent 20px,
                    rgba(139,69,19,0.1) 40px,
                    transparent 60px
                ),
                radial-gradient(ellipse at 30% 40%, transparent 20%, rgba(101,67,33,0.3) 60%, transparent 80%),
                radial-gradient(ellipse at 70% 60%, transparent 20%, rgba(139,69,19,0.2) 60%, transparent 80%);
            border-radius: 20px 20px 40px 40px;
        }

        .stand-base {
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            height: 25px;
            background: linear-gradient(180deg, #654321 0%, #4A4A4A 100%);
            border-radius: 50px;
            box-shadow: 
                0 5px 15px rgba(0,0,0,0.6),
                inset 0 2px 5px rgba(255,255,255,0.1);
        }

        .machine-nameplate {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(45deg, #FFD700, #FFA500);
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            color: #8B4513;
            font-size: 16px;
            box-shadow: 
                0 3px 10px rgba(0,0,0,0.4),
                inset 0 2px 4px rgba(255,255,255,0.4);
            border: 2px solid #B8860B;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.3);
        }

        #gameCanvas {
            background: radial-gradient(circle at center, #1a1a2e 0%, #0f0f23 100%);
            border: 3px solid #ffd700;
            border-radius: 15px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
            position: relative;
            z-index: 1;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .speed-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }

        .lottery-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            font-size: 18px;
            padding: 15px 30px;
        }

        .reset-btn {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .result-display {
            margin-top: 20px;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            background: rgba(255,255,255,0.9);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .status-display {
            color: white;
            font-size: 18px;
            margin: 10px 0;
            text-align: center;
        }

        .prize-input {
            display: flex;
            gap: 15px;
            margin: 15px 0;
            flex-wrap: wrap;
            justify-content: center;
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(5px);
        }

        .prize-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            background: rgba(255,255,255,0.2);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        input {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            text-align: center;
            width: 80px;
            transition: all 0.3s ease;
        }

        input:focus {
            border-color: #FFD700;
            box-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
            outline: none;
        }

        .quantity-input {
            width: 60px;
            font-weight: bold;
        }

        label {
            color: white;
            font-weight: bold;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .prize-color-indicator {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ffd700;
            animation: fall 3s linear infinite;
        }

        @keyframes fall {
            0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
        }

        .celebration {
            animation: bounce 0.6s ease-in-out infinite alternate;
        }

        @keyframes bounce {
            0% { transform: scale(1); }
            100% { transform: scale(1.05); }
        }
    </style>
</head>
<body>
    <div class="title">ğŸ¯ æ—¥æœ¬æŠ½é¸å™¨ ğŸ¯</div>
    
    <div class="game-container">
        <div class="lottery-machine">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            
            <div class="machine-stand">
                <div class="wood-grain"></div>
                <div class="machine-nameplate">ğŸŠ æ—¥æœ¬æŠ½é¸å™¨ ğŸŠ</div>
                <div class="stand-base"></div>
            </div>
        </div>
        
        <div class="prize-input">
            <div class="prize-group">
                <div class="prize-color-indicator" style="background: #FFD700;"></div>
                <label>é‡‘çåç¨±</label>
                <input type="text" id="goldPrize" value="ç‰¹ç­‰ç" maxlength="10">
                <label>æ•¸é‡</label>
                <input type="number" id="goldCount" class="quantity-input" value="1" min="0" max="10">
            </div>
            <div class="prize-group">
                <div class="prize-color-indicator" style="background: #FF4444;"></div>
                <label>ç´…çåç¨±</label>
                <input type="text" id="redPrize" value="ä¸€ç­‰ç" maxlength="10">
                <label>æ•¸é‡</label>
                <input type="number" id="redCount" class="quantity-input" value="1" min="0" max="10">
            </div>
            <div class="prize-group">
                <div class="prize-color-indicator" style="background: #44FF44;"></div>
                <label>ç¶ çåç¨±</label>
                <input type="text" id="greenPrize" value="äºŒç­‰ç" maxlength="10">
                <label>æ•¸é‡</label>
                <input type="number" id="greenCount" class="quantity-input" value="1" min="0" max="10">
            </div>
            <div class="prize-group">
                <div class="prize-color-indicator" style="background: #4488FF;"></div>
                <label>è—çåç¨±</label>
                <input type="text" id="bluePrize" value="ä¸‰ç­‰ç" maxlength="10">
                <label>æ•¸é‡</label>
                <input type="number" id="blueCount" class="quantity-input" value="1" min="0" max="10">
            </div>
            <div class="prize-group">
                <div class="prize-color-indicator" style="background: #FFFFFF;"></div>
                <label>ç™½çƒ(æœªä¸­ç)</label>
                <input type="text" id="whitePrize" value="æœªä¸­ç" maxlength="10" readonly style="background: #f0f0f0;">
                <label>æ•¸é‡</label>
                <input type="number" id="whiteCount" class="quantity-input" value="20" min="1" max="50">
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <button class="speed-btn" onclick="adjustSpeed(0.05)">ğŸ”¼ åŠ é€Ÿ</button>
                <button class="speed-btn" onclick="adjustSpeed(-0.05)">ğŸ”½ æ¸›é€Ÿ</button>
            </div>
            
            <button class="lottery-btn" onclick="startLottery()">ğŸ² é–‹å§‹æŠ½é¸</button>
            <button class="reset-btn" onclick="resetGame()">ğŸ”„ é‡æ–°é–‹å§‹</button>
            <button class="reset-btn" onclick="updateBalls()" style="background: linear-gradient(45deg, #9b59b6, #8e44ad);">âš™ï¸ æ›´æ–°çƒæ•¸</button>
        </div>

        <div class="status-display" id="statusDisplay">æ—‹è½‰é€Ÿåº¦: 0.005</div>
        <div class="result-display" id="resultDisplay">æº–å‚™æŠ½é¸ä¸­...</div>
    </div>

    <script>
        // ç²å– Canvas å’Œç›¸é—œå…ƒç´ 
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const resultDisplay = document.getElementById('resultDisplay');
        const statusDisplay = document.getElementById('statusDisplay');

        // éŠæˆ²å¸¸æ•¸
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;
        const CENTER = { x: WIDTH / 2, y: HEIGHT / 2 };
        const HEX_RADIUS = Math.min(WIDTH, HEIGHT) * 0.3;
        const BALL_RADIUS = 18; // çƒçš„åŠå¾‘
        const GRAVITY = 0.3;
        const FRICTION = 0.98;
        const EXIT_HOLE = { x: WIDTH - 150, y: HEIGHT - 120, radius: 25 };
        const SLOW_GRAVITY = 0.08; // æ…¢é€Ÿé‡åŠ›ï¼Œç”¨æ–¼çƒæ‰è½

        // éŠæˆ²ç‹€æ…‹
        let ROTATION_SPEED = 0.005;
        let targetSpeed = 0;
        let isSlowingDown = false;
        let slowDownTimer = 0;
        let gameState = 'spinning'; // 'spinning', 'slowing', 'stopped', 'dropping'
        let droppingBall = null;
        let currentResult = null;
        let confetti = [];

        // éŸ³æ•ˆç³»çµ±
        let audioContext = null;
        let rollingGainNode = null;
        let rollingOscillator = null;
        let isAudioEnabled = false;

        // çé …è¨­å®š
        function getPrizeTypes() {
            return {
                white: { 
                    color: '#FFFFFF', 
                    name: document.getElementById('whitePrize').value, 
                    count: parseInt(document.getElementById('whiteCount').value) || 20 
                },
                gold: { 
                    color: '#FFD700', 
                    name: document.getElementById('goldPrize').value, 
                    count: parseInt(document.getElementById('goldCount').value) || 1 
                },
                red: { 
                    color: '#FF4444', 
                    name: document.getElementById('redPrize').value, 
                    count: parseInt(document.getElementById('redCount').value) || 1 
                },
                green: { 
                    color: '#44FF44', 
                    name: document.getElementById('greenPrize').value, 
                    count: parseInt(document.getElementById('greenCount').value) || 1 
                },
                blue: { 
                    color: '#4488FF', 
                    name: document.getElementById('bluePrize').value, 
                    count: parseInt(document.getElementById('blueCount').value) || 1 
                }
            };
        }

        // çƒé™£åˆ—
        let balls = [];
        let rotation = 0;

        // åˆå§‹åŒ–çƒ
        function initBalls() {
            balls = [];
            const prizeTypes = getPrizeTypes();
            
            Object.keys(prizeTypes).forEach(type => {
                const prize = prizeTypes[type];
                for (let i = 0; i < prize.count; i++) {
                    // åœ¨å…­é‚Šå½¢å…§éš¨æ©Ÿåˆ†ä½ˆçƒ
                    let angle = Math.random() * Math.PI * 2;
                    let radius = Math.random() * (HEX_RADIUS - BALL_RADIUS);
                    
                    balls.push({
                        pos: {
                            x: CENTER.x + Math.cos(angle) * radius,
                            y: CENTER.y + Math.sin(angle) * radius
                        },
                        vel: {
                            x: (Math.random() - 0.5) * 3,
                            y: (Math.random() - 0.5) * 3
                        },
                        type: type,
                        color: prize.color,
                        name: prize.name,
                        active: true
                    });
                }
            });
        }

        // è¨ˆç®—å…­é‚Šå½¢é ‚é»
        function getHexagonVertices(rotation) {
            const vertices = [];
            for (let i = 0; i < 6; i++) {
                const angle = rotation + i * Math.PI / 3;
                const x = CENTER.x + HEX_RADIUS * Math.cos(angle);
                const y = CENTER.y + HEX_RADIUS * Math.sin(angle);
                vertices.push({ x, y });
            }
            return vertices;
        }

        // é»åˆ°ç·šæ®µè·é›¢
        function pointToLineDistance(point, lineStart, lineEnd) {
            const x0 = point.x, y0 = point.y;
            const x1 = lineStart.x, y1 = lineStart.y;
            const x2 = lineEnd.x, y2 = lineEnd.y;
            
            const l2 = (x2 - x1) ** 2 + (y2 - y1) ** 2;
            if (l2 === 0) return Math.sqrt((x0 - x1) ** 2 + (y0 - y1) ** 2);
            
            let t = ((x0 - x1) * (x2 - x1) + (y0 - y1) * (y2 - y1)) / l2;
            t = Math.max(0, Math.min(1, t));
            
            const projX = x1 + t * (x2 - x1);
            const projY = y1 + t * (y2 - y1);
            
            return Math.sqrt((x0 - projX) ** 2 + (y0 - projY) ** 2);
        }

        // ç·šæ®µæ³•å‘é‡
        function lineNormal(lineStart, lineEnd) {
            const dx = lineEnd.x - lineStart.x;
            const dy = lineEnd.y - lineStart.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            if (length === 0) return { x: 0, y: 0 };
            return { x: -dy / length, y: dx / length };
        }

        // æª¢æŸ¥çƒæ˜¯å¦åœ¨å‡ºå­”é™„è¿‘
        function checkExitHole(ball) {
            const distance = Math.sqrt(
                (ball.pos.x - EXIT_HOLE.x) ** 2 + 
                (ball.pos.y - EXIT_HOLE.y) ** 2
            );
            return distance < EXIT_HOLE.radius + BALL_RADIUS;
        }

        // åˆå§‹åŒ–éŸ³æ•ˆç³»çµ±
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                isAudioEnabled = true;
                console.log('éŸ³æ•ˆç³»çµ±åˆå§‹åŒ–æˆåŠŸ');
                return true;
            } catch (e) {
                console.log('éŸ³æ•ˆç³»çµ±åˆå§‹åŒ–å¤±æ•—:', e);
                isAudioEnabled = false;
                return false;
            }
        }

        // å‰µå»ºæ»¾å‹•éŸ³æ•ˆ
        function createRollingSound() {
            if (!isAudioEnabled || !audioContext) return;

            try {
                // åœæ­¢ä¹‹å‰çš„éŸ³æ•ˆ
                stopRollingSound();

                // å‰µå»ºç™½å™ªéŸ³ç”Ÿæˆå™¨ï¼ˆæ¨¡æ“¬æ»¾å‹•æ‘©æ“¦è²ï¼‰
                const bufferSize = 4096;
                const whiteNoise = audioContext.createScriptProcessor(bufferSize, 1, 1);
                whiteNoise.onaudioprocess = function(e) {
                    const output = e.outputBuffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        output[i] = Math.random() * 2 - 1;
                    }
                };

                // å‰µå»ºæ¿¾æ³¢å™¨ï¼ˆæ¨¡æ“¬çƒé«”æ»¾å‹•çš„ä½é »è²éŸ³ï¼‰
                const lowPassFilter = audioContext.createBiquadFilter();
                lowPassFilter.type = 'lowpass';
                lowPassFilter.frequency.value = 200 + ROTATION_SPEED * 1000; // æ ¹æ“šé€Ÿåº¦èª¿æ•´é »ç‡
                lowPassFilter.Q.value = 1;

                // å‰µå»ºé«˜é€šæ¿¾æ³¢å™¨
                const highPassFilter = audioContext.createBiquadFilter();
                highPassFilter.type = 'highpass';
                highPassFilter.frequency.value = 50;
                highPassFilter.Q.value = 1;

                // å‰µå»ºéŸ³é‡æ§åˆ¶
                rollingGainNode = audioContext.createGain();
                rollingGainNode.gain.value = Math.min(ROTATION_SPEED * 0.3, 0.15); // æ ¹æ“šæ—‹è½‰é€Ÿåº¦èª¿æ•´éŸ³é‡

                // é€£æ¥éŸ³æ•ˆéˆ
                whiteNoise.connect(highPassFilter);
                highPassFilter.connect(lowPassFilter);
                lowPassFilter.connect(rollingGainNode);
                rollingGainNode.connect(audioContext.destination);

                // ä¿å­˜å¼•ç”¨ä»¥ä¾¿å¾ŒçºŒæ§åˆ¶
                rollingOscillator = whiteNoise;

                console.log('æ»¾å‹•éŸ³æ•ˆå·²å‰µå»º');
            } catch (e) {
                console.log('å‰µå»ºæ»¾å‹•éŸ³æ•ˆå¤±æ•—:', e);
            }
        }

        // æ›´æ–°æ»¾å‹•éŸ³æ•ˆ
        function updateRollingSound() {
            if (!isAudioEnabled || !rollingGainNode) return;

            try {
                // æ ¹æ“šæ—‹è½‰é€Ÿåº¦å’Œçƒçš„æ´»å‹•ç¨‹åº¦èª¿æ•´éŸ³é‡
                const activeBalls = balls.filter(b => b.active).length;
                const baseVolume = Math.min(ROTATION_SPEED * 0.3, 0.15);
                const ballActivityMultiplier = Math.min(activeBalls / 10, 1);
                const targetVolume = baseVolume * ballActivityMultiplier;

                // å¹³æ»‘èª¿æ•´éŸ³é‡
                rollingGainNode.gain.linearRampToValueAtTime(
                    targetVolume, 
                    audioContext.currentTime + 0.1
                );
            } catch (e) {
                console.log('æ›´æ–°æ»¾å‹•éŸ³æ•ˆå¤±æ•—:', e);
            }
        }

        // åœæ­¢æ»¾å‹•éŸ³æ•ˆ
        function stopRollingSound() {
            if (rollingOscillator) {
                try {
                    rollingOscillator.disconnect();
                    rollingOscillator = null;
                } catch (e) {
                    console.log('åœæ­¢æ»¾å‹•éŸ³æ•ˆå¤±æ•—:', e);
                }
            }
            if (rollingGainNode) {
                try {
                    rollingGainNode.disconnect();
                    rollingGainNode = null;
                } catch (e) {
                    console.log('åœæ­¢å¢ç›Šç¯€é»å¤±æ•—:', e);
                }
            }
        }

        // å‰µå»ºçƒç¢°æ’éŸ³æ•ˆ
        function createCollisionSound(intensity = 0.5) {
            if (!isAudioEnabled || !audioContext) return;

            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // è¨­å®šç¢°æ’éŸ³æ•ˆåƒæ•¸
                oscillator.frequency.setValueAtTime(150 + Math.random() * 100, audioContext.currentTime);
                oscillator.type = 'triangle';

                gainNode.gain.setValueAtTime(intensity * 0.1, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
            } catch (e) {
                console.log('å‰µå»ºç¢°æ’éŸ³æ•ˆå¤±æ•—:', e);
            }
        }

        // å‰µå»ºçƒæ‰è½éŸ³æ•ˆ
        function createDropSound() {
            if (!isAudioEnabled || !audioContext) return;

            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // è¨­å®šæ‰è½éŸ³æ•ˆåƒæ•¸ï¼ˆå¾é«˜åˆ°ä½çš„æ»‘éŸ³ï¼‰
                oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.5);
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            } catch (e) {
                console.log('å‰µå»ºæ‰è½éŸ³æ•ˆå¤±æ•—:', e);
            }
        }
        function createConfetti() {
            for (let i = 0; i < 50; i++) {
                confetti.push({
                    x: Math.random() * WIDTH,
                    y: -10,
                    vx: (Math.random() - 0.5) * 4,
                    vy: Math.random() * 3 + 2,
                    color: ['#FFD700', '#FF4444', '#44FF44', '#4488FF', '#FF44FF'][Math.floor(Math.random() * 5)],
                    size: Math.random() * 8 + 4,
                    life: 200
                });
            }
        }

        // æ›´æ–°å½©å¸¶
        function updateConfetti() {
            for (let i = confetti.length - 1; i >= 0; i--) {
                const c = confetti[i];
                c.x += c.vx;
                c.y += c.vy;
                c.vy += 0.1; // é‡åŠ›
                c.life--;
                
                if (c.life <= 0 || c.y > HEIGHT) {
                    confetti.splice(i, 1);
                }
            }
        }

        // ç¹ªè£½å½©å¸¶
        function drawConfetti() {
            confetti.forEach(c => {
                ctx.save();
                ctx.globalAlpha = c.life / 200;
                ctx.fillStyle = c.color;
                ctx.fillRect(c.x, c.y, c.size, c.size);
                ctx.restore();
            });
        }

        // ç¹ªè£½å‡½æ•¸
        function draw() {
            // æ¸…ç©ºç•«å¸ƒ
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            
            // ç¹ªè£½èƒŒæ™¯æ•ˆæœ
            const gradient = ctx.createRadialGradient(CENTER.x, CENTER.y, 0, CENTER.x, CENTER.y, HEX_RADIUS);
            gradient.addColorStop(0, 'rgba(100, 100, 255, 0.1)');
            gradient.addColorStop(1, 'rgba(100, 100, 255, 0.05)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            
            // ç²å–å…­é‚Šå½¢é ‚é»
            const vertices = getHexagonVertices(rotation);
            
            // ç¹ªè£½å…­é‚Šå½¢
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < vertices.length; i++) {
                ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            ctx.closePath();
            ctx.strokeStyle = '#6464FF';
            ctx.lineWidth = 4;
            ctx.stroke();
            
            // ç¹ªè£½å…­é‚Šå½¢ç™¼å…‰æ•ˆæœ
            ctx.shadowColor = '#6464FF';
            ctx.shadowBlur = 10;
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // ç¹ªè£½å‡ºå­” - ä½æ–¼å…­è§’å½¢å³ä¸‹æ–¹é è¿‘ä¸‹ç·£1/3è™•
            ctx.save();
            
            // å‡ºå­”å¤–åœˆç™¼å…‰æ•ˆæœ
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 15;
            
            ctx.beginPath();
            ctx.arc(EXIT_HOLE.x, EXIT_HOLE.y, EXIT_HOLE.radius + 5, 0, Math.PI * 2);
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.shadowBlur = 0;
            
            // å‡ºå­”çš„å…§éƒ¨æ•ˆæœ
            ctx.beginPath();
            ctx.arc(EXIT_HOLE.x, EXIT_HOLE.y, EXIT_HOLE.radius, 0, Math.PI * 2);
            
            const holeGradient = ctx.createRadialGradient(
                EXIT_HOLE.x, EXIT_HOLE.y, 0,
                EXIT_HOLE.x, EXIT_HOLE.y, EXIT_HOLE.radius
            );
            holeGradient.addColorStop(0, '#000');
            holeGradient.addColorStop(0.6, '#111');
            holeGradient.addColorStop(0.8, '#333');
            holeGradient.addColorStop(1, '#FFD700');
            
            ctx.fillStyle = holeGradient;
            ctx.fill();
            
            // å‡ºå­”é‚Šæ¡†
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // å‡ºå­”æ–¹å‘ç®­é ­
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('â†“', EXIT_HOLE.x, EXIT_HOLE.y + 5);
            
            // å‡ºå­”æ¨™ç¤º
            ctx.font = '14px Arial';
            ctx.fillStyle = '#FFD700';
            ctx.textAlign = 'center';
            ctx.fillText('å‡ºå­”', EXIT_HOLE.x, EXIT_HOLE.y + EXIT_HOLE.radius + 25);
            
            ctx.restore();
            
            // ç¹ªè£½çƒ
            balls.forEach(ball => {
                if (ball.active) {
                    // çƒçš„é™°å½±æ•ˆæœ
                    ctx.save();
                    ctx.shadowColor = 'rgba(0,0,0,0.3)';
                    ctx.shadowBlur = 8;
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;
                    
                    ctx.beginPath();
                    ctx.arc(ball.pos.x, ball.pos.y, BALL_RADIUS, 0, Math.PI * 2);
                    ctx.fillStyle = ball.color;
                    ctx.fill();
                    
                    // çƒçš„é‚Šæ¡†
                    ctx.strokeStyle = ball.type === 'white' ? '#CCC' : '#FFF';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // çƒçš„é«˜å…‰æ•ˆæœ
                    ctx.beginPath();
                    ctx.arc(ball.pos.x - 8, ball.pos.y - 8, BALL_RADIUS / 3, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255,255,255,0.4)';
                    ctx.fill();
                    
                    ctx.restore();
                }
            });
            
            // ç¹ªè£½æ‰è½çš„çƒ
            if (droppingBall) {
                ctx.save();
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 12;
                
                ctx.beginPath();
                ctx.arc(droppingBall.pos.x, droppingBall.pos.y, BALL_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = droppingBall.color;
                ctx.fill();
                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.restore();
            }
            
            // ç¹ªè£½å½©å¸¶
            drawConfetti();
            
            // é¡¯ç¤ºç‹€æ…‹ä¿¡æ¯
            ctx.font = '18px Arial';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'left';
            ctx.fillText(`å‰©é¤˜çƒæ•¸: ${balls.filter(b => b.active).length}`, 20, 30);
            ctx.fillText(`éŠæˆ²ç‹€æ…‹: ${getGameStateText()}`, 20, 55);
        }

        // ç²å–éŠæˆ²ç‹€æ…‹æ–‡å­—
        function getGameStateText() {
            switch(gameState) {
                case 'spinning': return 'æ—‹è½‰ä¸­';
                case 'slowing': return 'æ¸›é€Ÿä¸­';
                case 'stopped': return 'å·²åœæ­¢';
                case 'dropping': return 'çƒæ‰è½ä¸­';
                default: return 'æœªçŸ¥ç‹€æ…‹';
            }
        }

        // æ›´æ–°éŠæˆ²é‚è¼¯
        function update() {
            // è™•ç†æ¸›é€Ÿ
            if (isSlowingDown && slowDownTimer > 0) {
                slowDownTimer--;
                const progress = (600 - slowDownTimer) / 600;
                ROTATION_SPEED = 0.005 * (1 - progress * 0.9); // ä¿ç•™10%çš„é€Ÿåº¦é¿å…å®Œå…¨åœæ­¢
                
                if (slowDownTimer <= 0) {
                    ROTATION_SPEED = 0;
                    gameState = 'stopped';
                    isSlowingDown = false;
                    
                    // åœæ­¢æ»¾å‹•éŸ³æ•ˆ
                    stopRollingSound();
                    
                    // é¸æ“‡ä¸€å€‹çƒæ‰è½
                    setTimeout(() => {
                        selectBallToDrop();
                    }, 1000);
                }
            }
            
            // æ›´æ–°æ—‹è½‰
            rotation += ROTATION_SPEED;
            
            // æ›´æ–°æ»¾å‹•éŸ³æ•ˆ
            if (gameState === 'spinning' || gameState === 'slowing') {
                updateRollingSound();
            }
            
            // æ›´æ–°æ‰è½çƒ
            if (droppingBall) {
                // çƒæ…¢æ…¢å¾å‡ºå­”æ‰è½ï¼Œä½¿ç”¨è¼ƒè¼•çš„é‡åŠ›
                droppingBall.vel.y += SLOW_GRAVITY;
                droppingBall.pos.x += droppingBall.vel.x;
                droppingBall.pos.y += droppingBall.vel.y;
                
                // æª¢æŸ¥çƒæ˜¯å¦æ‰å‡ºç•«é¢
                if (droppingBall.pos.y > HEIGHT + BALL_RADIUS) {
                    console.log('çƒæ‰å‡ºç•«é¢ï¼Œé¡¯ç¤ºçµæœ');
                    showResult(droppingBall);
                    droppingBall = null;
                }
            }
            
            // åªåœ¨æ—‹è½‰æ™‚æ›´æ–°çƒçš„ç‰©ç†
            if (gameState === 'spinning' || gameState === 'slowing') {
                const vertices = getHexagonVertices(rotation);
                
                balls.forEach(ball => {
                    if (!ball.active) return;
                    
                    // æ‡‰ç”¨é‡åŠ›
                    ball.vel.y += GRAVITY;
                    
                    // æ›´æ–°ä½ç½®
                    ball.pos.x += ball.vel.x;
                    ball.pos.y += ball.vel.y;
                    
                    // å…­é‚Šå½¢é‚Šç•Œç¢°æ’æª¢æ¸¬
                    for (let i = 0; i < 6; i++) {
                        const start = vertices[i];
                        const end = vertices[(i + 1) % 6];
                        const distance = pointToLineDistance(ball.pos, start, end);
                        
                        if (distance < BALL_RADIUS) {
                            const normal = lineNormal(start, end);
                            const centerToBall = {
                                x: ball.pos.x - CENTER.x,
                                y: ball.pos.y - CENTER.y
                            };
                            
                            if (normal.x * centerToBall.x + normal.y * centerToBall.y > 0) {
                                normal.x = -normal.x;
                                normal.y = -normal.y;
                            }
                            
                            const velocityDotNormal = ball.vel.x * normal.x + ball.vel.y * normal.y;
                            ball.vel.x = (ball.vel.x - 2 * velocityDotNormal * normal.x) * FRICTION;
                            ball.vel.y = (ball.vel.y - 2 * velocityDotNormal * normal.y) * FRICTION;
                            
                            const overlap = BALL_RADIUS - distance;
                            ball.pos.x += normal.x * overlap;
                            ball.pos.y += normal.y * overlap;
                            
                            // æ’­æ”¾ç¢°æ’éŸ³æ•ˆ
                            const collisionIntensity = Math.min(Math.abs(velocityDotNormal), 1);
                            if (collisionIntensity > 0.3) {
                                createCollisionSound(collisionIntensity);
                            }
                        }
                    }
                    
                    // çƒèˆ‡çƒç¢°æ’
                    balls.forEach(otherBall => {
                        if (otherBall === ball || !otherBall.active) return;
                        
                        const dx = ball.pos.x - otherBall.pos.x;
                        const dy = ball.pos.y - otherBall.pos.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < BALL_RADIUS * 2) {
                            const angle = Math.atan2(dy, dx);
                            const targetX = otherBall.pos.x + Math.cos(angle) * BALL_RADIUS * 2;
                            const targetY = otherBall.pos.y + Math.sin(angle) * BALL_RADIUS * 2;
                            
                            const ax = (targetX - ball.pos.x) * 0.1;
                            const ay = (targetY - ball.pos.y) * 0.1;
                            
                            ball.vel.x += ax;
                            ball.vel.y += ay;
                            otherBall.vel.x -= ax;
                            otherBall.vel.y -= ay;
                            
                            // æ’­æ”¾çƒèˆ‡çƒç¢°æ’éŸ³æ•ˆ
                            const collisionForce = Math.sqrt(ax * ax + ay * ay);
                            if (collisionForce > 0.1) {
                                createCollisionSound(collisionForce * 2);
                            }
                        }
                    });
                });
            }
            
            // æ›´æ–°å½©å¸¶
            updateConfetti();
            
            // æ›´æ–°ç‹€æ…‹é¡¯ç¤º
            statusDisplay.textContent = `æ—‹è½‰é€Ÿåº¦: ${ROTATION_SPEED.toFixed(4)} | éŠæˆ²ç‹€æ…‹: ${getGameStateText()}`;
        }

        // é¸æ“‡çƒæ‰è½
        function selectBallToDrop() {
            const activeBalls = balls.filter(ball => ball.active);
            if (activeBalls.length === 0) return;
            
            // éš¨æ©Ÿé¸æ“‡ä¸€é¡†çƒ
            const selectedBall = activeBalls[Math.floor(Math.random() * activeBalls.length)];
            
            if (selectedBall) {
                // è¨­å®šæ‰è½çƒï¼Œç›´æ¥å¾å‡ºå­”ä½ç½®é–‹å§‹æ…¢æ…¢æ‰è½
                droppingBall = {
                    pos: { x: EXIT_HOLE.x, y: EXIT_HOLE.y }, // ç›´æ¥å¾å‡ºå­”ä½ç½®é–‹å§‹
                    vel: { 
                        x: (Math.random() - 0.5) * 0.5, // å¾ˆè¼•å¾®çš„æ°´å¹³éš¨æ©Ÿæ€§
                        y: 0.5 // å¾ˆæ…¢çš„åˆå§‹å‘ä¸‹é€Ÿåº¦
                    },
                    color: selectedBall.color,
                    type: selectedBall.type,
                    name: selectedBall.name
                };
                
                // ç§»é™¤åŸçƒ
                selectedBall.active = false;
                gameState = 'dropping';
                
                // æ’­æ”¾çƒæ‰è½éŸ³æ•ˆ
                createDropSound();
                
                console.log(`é¸ä¸­çƒ: ${selectedBall.name}, é–‹å§‹æ…¢æ…¢å¾å‡ºå­”æ‰è½`);
            }
        }

        // é¡¯ç¤ºçµæœ
        function showResult(ball) {
            currentResult = ball;
            
            if (ball.type !== 'white') {
                // æœ‰çé …ï¼Œå‰µå»ºæ…¶ç¥æ•ˆæœ
                createConfetti();
                resultDisplay.innerHTML = `ğŸ‰ æ­å–œç²å¾— ${ball.name}ï¼ğŸ‰`;
                resultDisplay.style.background = 'linear-gradient(45deg, #FFD700, #FF6B6B)';
                resultDisplay.style.color = 'white';
                resultDisplay.classList.add('celebration');
                
                // æ’­æ”¾æ…¶ç¥éŸ³æ•ˆï¼ˆå¦‚æœç€è¦½å™¨æ”¯æ´ï¼‰
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                    oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
                    oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.5);
                } catch (e) {
                    console.log('ç„¡æ³•æ’­æ”¾éŸ³æ•ˆ');
                }
            } else {
                // æœªä¸­ç
                resultDisplay.innerHTML = 'å¾ˆéºæ†¾ï¼Œæœªä¸­ç';
                resultDisplay.style.background = 'rgba(128,128,128,0.9)';
                resultDisplay.style.color = 'white';
                resultDisplay.classList.remove('celebration');
            }
            
            gameState = 'finished';
        }

        // æ§åˆ¶å‡½æ•¸
        function adjustSpeed(delta) {
            if (gameState === 'spinning') {
                ROTATION_SPEED = Math.max(0.001, Math.min(1.0, ROTATION_SPEED + delta));
            }
        }

        function startLottery() {
            if (gameState === 'spinning' && balls.filter(b => b.active).length > 0) {
                // é¦–æ¬¡é»æ“Šæ™‚åˆå§‹åŒ–éŸ³æ•ˆï¼ˆéœ€è¦ç”¨æˆ¶äº’å‹•æ‰èƒ½å•Ÿå‹•éŸ³æ•ˆï¼‰
                if (!audioContext) {
                    initAudio();
                }
                
                isSlowingDown = true;
                slowDownTimer = 600; // 10ç§’
                gameState = 'slowing';
                resultDisplay.innerHTML = 'æŠ½é¸é€²è¡Œä¸­...';
                resultDisplay.style.background = 'rgba(255,255,255,0.9)';
                resultDisplay.style.color = '#333';
                resultDisplay.classList.remove('celebration');
            }
        }

        function updateBalls() {
            if (gameState === 'spinning') {
                initBalls();
                resultDisplay.innerHTML = 'çƒæ•¸å·²æ›´æ–°ï¼';
                resultDisplay.style.background = 'rgba(144,238,144,0.9)';
                resultDisplay.style.color = '#333';
                resultDisplay.classList.remove('celebration');
                
                // 3ç§’å¾Œæ¢å¾©åŸå§‹ç‹€æ…‹
                setTimeout(() => {
                    if (gameState === 'spinning') {
                        resultDisplay.innerHTML = 'æº–å‚™æŠ½é¸ä¸­...';
                        resultDisplay.style.background = 'rgba(255,255,255,0.9)';
                    }
                }, 3000);
            }
        }

        function resetGame() {
            // åœæ­¢æ‰€æœ‰éŸ³æ•ˆ
            stopRollingSound();
            
            // é‡ç½®æ‰€æœ‰ç‹€æ…‹
            initBalls();
            droppingBall = null;
            currentResult = null;
            confetti = [];
            isSlowingDown = false;
            slowDownTimer = 0;
            gameState = 'spinning';
            ROTATION_SPEED = 0.005;
            rotation = 0;
            
            resultDisplay.innerHTML = 'æº–å‚™æŠ½é¸ä¸­...';
            resultDisplay.style.background = 'rgba(255,255,255,0.9)';
            resultDisplay.style.color = '#333';
            resultDisplay.classList.remove('celebration');
            
            // é‡æ–°é–‹å§‹æ»¾å‹•éŸ³æ•ˆ
            if (isAudioEnabled) {
                setTimeout(() => {
                    createRollingSound();
                }, 100);
            }
        }

        // éŠæˆ²ä¸»å¾ªç’°
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // åˆå§‹åŒ–ä¸¦é–‹å§‹éŠæˆ²
        initBalls();
        gameLoop();

        // æ·»åŠ éŸ³æ•ˆæ§åˆ¶æç¤º
        console.log('ğŸ’¡ æç¤º: é»æ“Š"é–‹å§‹æŠ½é¸"æŒ‰éˆ•å¾Œå°‡å•Ÿå‹•éŸ³æ•ˆç³»çµ±');
        console.log('ğŸ”Š éŸ³æ•ˆåŒ…å«: çƒæ»¾å‹•è²ã€ç¢°æ’è²ã€æ‰è½è²å’Œæ…¶ç¥éŸ³æ•ˆ');

        // éµç›¤æ§åˆ¶ï¼ˆå¯é¸ï¼‰
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp':
                    adjustSpeed(0.05);
                    break;
                case 'ArrowDown':
                    adjustSpeed(-0.05);
                    break;
                case ' ':
                    e.preventDefault();
                    startLottery();
                    break;
                case 'r':
                    resetGame();
                    break;
            }
        });
    </script>
</body>
</html>